>>> FORME DE COMMUNICATION:

a first line with the info for version etc, 
zero or more header fields (collectively referred to as
the "headers" or the "header section"), an empty line indicating the
end of the header section, and an optional message body.

CLIENT > SERVER:
METHODS URI VERSION
HEADERS

BODY

---------------
SERVER > CLIENT:
VERSION CODE SENTENCE
HEADERS

BODY

__________________________________________________________________________________________
>>> URI
http-URI = "http:" "//" IP:PORT path_to_the_file [ "?" query ]

la path_to_he_file peut contenir des caracteres exa qui peuvent representer certains caracteres en focntion de l'encodage

__________________________________________________________________________________________
>>> HOW TO TREAT A REQUEST

The normal procedure for parsing an HTTP message is to read the
start-line into a structure, read each header field into a hash table
by field name until the empty line, and then use the parsed data to
determine if a message body is expected.  If a message body has been
indicated, then it is read as a stream until an amount of octets
equal to the message body length is read or the connection is closed.

A recipient MUST parse an HTTP message as a sequence of octets in an
encoding that is a superset of US-ASCII [USASCII].

__________________________________________________________________________________________
>>> WHATS AN HTTP MESSAGE

HTTP-message   = start-line
                *( header-field CRLF )
                CRLF
                [ message-body ]

__________________________________________________________________________________________
>>> IMPLEMENTING START LINE

> An HTTP message can be either a request from client to server or a
response from server to client.  Syntactically, the two types of
message differ only in the start-line, which is either a request-line
(for requests) or a status-line (for responses), and in the algorithm
for determining the length of the message body. A sender MUST NOT send 
whitespace between the start-line and the first header field.

    start-line     = request-line / status-line

> A request-line begins with a method token, followed by a single space
(SP), the request-target, another single space (SP), the protocol
version, and ends with CRLF. The request method is case-sensitive.

     request-line   = method SP request-target SP HTTP-version CRLF

Recipients of an invalid request-line (with whitespace for example) SHOULD respond with either a
400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.
A recipient SHOULD NOT attempt
to autocorrect and then process the request without a redirect, since
the invalid request-line might be deliberately crafted to bypass
security filters along the request chain.

HTTP does not place a predefined limit on the length of a
request-line, as described in Section 2.5.  A server that receives a
method longer than any that it implements SHOULD respond with a 501
(Not Implemented) status code.  A server that receives a
request-target longer than any URI it wishes to parse MUST respond
with a 414 (URI Too Long) status code (see Section 6.5.12 of
[RFC7231]).

Various ad hoc limitations on request-line length are found in
practice.  It is RECOMMENDED that all HTTP senders and recipients
support, at a minimum, request-line lengths of 8000 octets.

> A status line consist of the protocol version, a space (SP), the status code, another
space, a possibly empty textual phrase describing the status code,
and ending with CRLF.

     status-line = HTTP-version SP status-code SP reason-phrase CRLF
	status-code    = 3DIGIT
	reason-phrase  = *( HTAB / SP / VCHAR / obs-text )

__________________________________________________________________________________________
>>> IMPLEMENTING HEADER FIELD 

> Each header field consists of a case-insensitive field name followed
by a colon (":"), optional leading whitespace, the field value, and
optional trailing whitespace.

	header-field   = field-name ":" OWS field-value OWS

No limitation on the number of header fields used in a given message.
The order in which header fields with differing field names are received is not significant.

No whitespace is allowed between the header field-name and colon.
A server MUST reject any received request message that contains
whitespace between a header field-name and colon with a response code
of 400 (Bad Request).

A field value might be preceded and/or followed by optional
whitespace (OWS); a single SP preceding the field-value is preferred.

HTTP does not place a predefined limit on the length of each header
field or on the length of the header section. A server that receives a request header field, or set of fields,
larger than it wishes to process MUST respond with an appropriate 4xx (Client Error) status code.

A recipient MAY combine multiple header fields with the same field
name into one "field-name: field-value" pair, without changing the
semantics of the message, by appending each subsequent field value to
the combined field value in order, separated by a comma.  The order
in which header fields with the same field name are received is
therefore significant to the interpretation of the combined field
value.

 Most HTTP header field values are defined using common syntax
components (token, quoted-string, and comment) separated by
whitespace or specific delimiting characters.  Delimiters are chosen
from the set of US-ASCII visual characters not allowed in a token
(DQUOTE and "(),/:;<=>?@[\]{}").

	token          = 1*tchar

	tchar          = "!" / "#" / "$" / "%" / "&" / "'" / "*"
				/ "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
				/ DIGIT / ALPHA
				; any VCHAR, except delimiters

A string of text is parsed as a single value if it is quoted using
double-quote marks.

	quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
	qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
	obs-text       = %x80-FF

Comments can be included in some HTTP header fields by surrounding
the comment text with parentheses.  Comments are only allowed in
fields containing "comment" as part of their field value definition.

__________________________________________________________________________________________
>>> IMPLEMENTING MESSAGE BODY

   message-body = *OCTET

The rules for when a message body is allowed in a message differ for
requests and responses.

The presence of a message body in a request is signaled by a
Content-Length or Transfer-Encoding header field.

The presence of a message body in a response depends on both the
request method to which it is responding and the response status code
(Section 3.1.2).  Responses to the HEAD request method (Section 4.3.2
of [RFC7231]) never include a message body because the associated
response header fields (e.g., Transfer-Encoding, Content-Length,
etc.), if present, indicate only what their values would have been if
the request method had been GET.

2xx (Successful) responses to a CONNECT request method (Section 4.3.6 of
[RFC7231]) switch to tunnel mode instead of having a message body.
All 1xx (Informational), 204 (No Content), and 304 (Not Modified)
responses do not include a message body.  All other responses do
include a message body, although the body might be of zero length.

> The Transfer-Encoding header field lists the transfer coding names
corresponding to the sequence of transfer codings that have been (or
will be) applied to the payload body in order to form the message
body

For example,

     Transfer-Encoding: gzip, chunked

indicates that the payload body has been compressed using the gzip
coding and then chunked using the chunked coding while forming the
message body.

Transfer-Encoding MAY be sent in a response to a HEAD request or in a
304 (Not Modified) response (Section 4.1 of [RFC7232]) to a GET
request, neither of which includes a message body, to indicate that
the origin server would have applied a transfer coding to the message
body if the request had been an unconditional GET.

A server MUST NOT send a Transfer-Encoding header field in any
response with a status code of 1xx (Informational) or 204 (No
Content).  A server MUST NOT send a Transfer-Encoding header field in
any 2xx (Successful) response to a CONNECT request


> When a message does not have a Transfer-Encoding header field, a
Content-Length header field can provide the anticipated size, as a
decimal number of octets, for a potential payload body.  For messages
that do include a payload body, the Content-Length field-value
provides the framing information necessary for determining where the
body (and message) ends. 

A server MAY send a Content-Length header field in a response to a
HEAD request (Section 4.3.2 of [RFC7231]); a server MUST NOT send
Content-Length in such a response unless its field-value equals the
decimal number of octets that would have been sent in the payload
body of a response if the same request had used the GET method.

A server MAY send a Content-Length header field in a 304 (Not
Modified) response to a conditional GET request (Section 4.1 of
[RFC7232]); a server MUST NOT send Content-Length in such a response
unless its field-value equals the decimal number of octets that would
have been sent in the payload body of a 200 (OK) response to the same
request.

A server MUST NOT send a Content-Length header field in any response
with a status code of 1xx (Informational) or 204 (No Content).  A
server MUST NOT send a Content-Length header field in any 2xx
(Successful) response to a CONNECT request (Section 4.3.6 of
[RFC7231]).

Aside from the cases defined above, in the absence of
Transfer-Encoding, an origin server SHOULD send a Content-Length
header field when the payload body size is known

Any Content-Length field value greater than or equal to zero is
valid.  Since there is no predefined limit to the length of a
payload, a recipient MUST anticipate potentially large decimal
numerals and prevent parsing errors due to integer conversion
overflows (Section 9.3).


> Message body length
!!!!!!!!!!!!!!!!!!! lire page 31!!!!!!!!!!
tres important permet de comprendre comment on doit recevoir les messaes et s'il faut 
renvoyer des erreurs ou non

Since there is no way to distinguish a successfully completed,
close-delimited message from a partially received message interrupted
by network failure, a server SHOULD generate encoding or
length-delimited messages whenever possible.


> Handling Incomplete Messages

A server that receives an incomplete request message, usually due to
a canceled request or a triggered timeout exception, MAY send an
error response prior to closing the connection.

A message body that uses the chunked transfer coding is incomplete if
the zero-sized chunk that terminates the encoding has not been
received.  A message that uses a valid Content-Length is incomplete
if the size of the message body received (in octets) is less than the
value given by Content-Length.  A response that has neither chunked
transfer coding nor Content-Length is terminated by closure of the
connection and, thus, is considered complete regardless of the number
of message body octets received, provided that the header section was
received intact.


> Message Parsing Robustness

If terminating the request
message body with a line-ending is desired, then the user agent MUST
count the terminating CRLF octets as part of the message body length.

In the interest of robustness, a server that is expecting to receive
and parse a request-line SHOULD ignore at least one empty line (CRLF)
received prior to the request-line.

When a server listening only for HTTP request messages, or processing
what appears from the start-line to be an HTTP request message,
receives a sequence of octets that does not match the HTTP-message
grammar aside from the robustness exceptions listed above, the server
SHOULD respond with a 400 (Bad Request) response.


> Transfer encoding

Transfer coding names are used to indicate an encoding transformation
that has been, can be, or might need to be applied to a payload body
in order to ensure "safe transport" through the network.  This
differs from a content coding in that the transfer coding is a
property of the message rather than a property of the representation
that is being transferred.

	transfer-coding    = "chunked" ; Section 4.1
					/ "compress" ; Section 4.2.1
					/ "deflate" ; Section 4.2.2
					/ "gzip" ; Section 4.2.3
					/ transfer-extension
	transfer-extension = token *( OWS ";" OWS transfer-parameter )

Parameters are in the form of a name or name=value pair.
All transfer-coding names are case-insensitive.

The chunked transfer coding wraps the payload body in order to
transfer it as a series of chunks, each with its own size indicator,
followed by an OPTIONAL trailer containing header fields.  Chunked
enables content streams of unknown size to be transferred as a
sequence of length-delimited buffers, which enables the sender to
retain connection persistence and the recipient to know when it has
received the entire message.

	chunked-body   = *chunk
					last-chunk
					trailer-part
					CRLF

	chunk          = chunk-size [ chunk-ext ] CRLF
					chunk-data CRLF
	chunk-size     = 1*HEXDIG
	last-chunk     = 1*("0") [ chunk-ext ] CRLF

	chunk-data     = 1*OCTET ; a sequence of chunk-size octets

The chunk-size field is a string of hex digits indicating the size of
the chunk-data in octets.  The chunked transfer coding is complete
when a chunk with a chunk-size of zero is received, possibly followed
by a trailer, and finally terminated by an empty line.

A recipient MUST be able to parse and decode the chunked transfer
coding.


> HOST

The "Host" header field in a request provides the host and port
information from the target URI, enabling the origin server to
distinguish among resources while servicing requests for multiple
host names on a single IP address.

For example, a GET request to the origin server for
<http://www.example.org/pub/WWW/> would begin with:

	GET /pub/WWW/ HTTP/1.1
	Host: www.example.org

A server MUST respond with a 400 (Bad Request) status code to any
HTTP/1.1 request message that lacks a Host header field and to any
request message that contains more than one Host header field or a
Host header field with an invalid field-value.




>>>>>>>>>>>>>>> 5.7.1.  Via
je me suis arrete ici